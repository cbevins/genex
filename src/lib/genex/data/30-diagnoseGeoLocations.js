// Reads known PLAC contents and writes their standard locations and counts
import fs from 'fs'
import { _gedcomKnownPlaces} from './customized/_gedcomKnownPlacesMASTER.js'

function fix(str) { return JSON.stringify(str) }

const time1 = new Date()
const progName = (process.argv[1]).split('\\').pop()

const masterFile = './customized/_gedcomKnownPlacesMASTER.js'
const varName = '_geoLocationCounts'
const outputFile = `./diagnostics/genex/${varName}.js`

const geoLocations = new Map()
for(let i=0; i<_gedcomKnownPlaces.length; i++) {
    const [content, standard] = _gedcomKnownPlaces[i]
    if (! geoLocations.has()) geoLocations.set(standard, 0)
    const n = geoLocations.get(standard)
    geoLocations.set(standard, n+1)
}
const ar = Array.from(geoLocations.entries()).sort()

// Write missing PLACes
let head = [
    `// auto-generated by ${progName} on ${new Date().toLocaleString()}`,
    `// from '${masterFile}'`,
    `// Each element is [<standardPlaceName>, <n>]`,
    `export const ${varName} = [`
]
let js = head.join('\n') + '\n'
for(let i=0; i<ar.length; i++) {
    const [key, entry] = ar[i]
    js += `    [${fix(key)}, ${entry}],\n`
}
js += ']\n'
fs.writeFile(outputFile, js, function (err) { if (err) throw err })

function summary() {
    const counts = [[], [], [], [], [], [], [], [], []]
    let maxSegs = 0
    for(let i=0; i<ar.length; i++) {
        const [geoLoc, n] = ar[i]
        const segments = geoLoc.split(',').length
        counts[segments].push(geoLoc)
    }

    for(let i=0; i<counts.length; i++) {
        console.log(`${counts[i].length} GeoLocations with ${i} segments`)
    }
    console.log(counts[1])
    console.log(counts[2])
    console.log(counts[3])
    console.log(counts[4])
}
// summary()

console.log(`\n${progName}`)
console.log(`    1 - read ${_gedcomKnownPlaces.length} known places from '${masterFile}'.`)
console.log(`    2 - wrote ${geoLocations.size} unique GeoLocations and counts to '${outputFile}'.`)
// console.log(`    3 - maximum segments was ${maxSegs}`)
console.log(`    Successfully completed in ${new Date()-time1} msec`)
